{
  "language": "Solidity",
  "sources": {
    "SpacedogexProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\nabstract contract Proxy {\n    function _delegate(address implementation) internal {\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    function _implementation() internal virtual view returns (address);\n\n    function _fallback() internal {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    fallback () payable external {\n        _fallback();\n    }\n\n    receive () payable external {\n        _fallback();\n    }\n\n    function _beforeFallback() internal virtual {}\n}\n\ncontract UpgradeableProxy is Proxy {\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    constructor(address _logic, bytes memory _data) public payable {\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            (bool success,) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n\n    function _implementation() internal override view returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n    }\n\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation));\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n        _setAdmin(_admin);\n    }\n\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    function changeAdmin(address newAdmin) external ifAdmin {\n        require(newAdmin != address(0));\n        _setAdmin(newAdmin);\n    }\n\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newImplementation);\n        (bool success,) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    function _beforeFallback() internal override {\n        require(msg.sender != _admin());\n        super._beforeFallback();\n    }\n}\n"
    },
    "SpacedogexTokenLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ncontract SpacedogexToken {\n    bool private _initialized;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    address public liquidityWallet;\n    address public feeWallet;\n    uint256 public feePercent;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    modifier initializer() {\n        require(!_initialized);\n        _;\n        _initialized = true;\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 initialSupply,\n        address liquidity_,\n        address fee_,\n        uint256 feeP_\n    ) public initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        liquidityWallet = liquidity_;\n        feeWallet = fee_;\n        feePercent = feeP_;\n        _mint(msg.sender, initialSupply);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0));\n        require(recipient != address(0));\n        uint256 fee = amount * feePercent / 10000;\n        uint256 amountAfterFee = amount - fee;\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amountAfterFee;\n        uint256 feeHalf = fee / 2;\n        _balances[liquidityWallet] = _balances[liquidityWallet] + feeHalf;\n        _balances[feeWallet] = _balances[feeWallet] + (fee - feeHalf);\n        emit Transfer(sender, recipient, amountAfterFee);\n        if(fee > 0) {\n            emit Transfer(sender, liquidityWallet, feeHalf);\n            emit Transfer(sender, feeWallet, fee - feeHalf);\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0));\n        require(spender != address(0));\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "metadata"
        ]
      }
    }
  }
}
